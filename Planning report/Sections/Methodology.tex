\section{Methodology}
\label{section:methodology}

As this project requires a good understanding of concepts for procedural content generation and various implementations of it, the initial objectives are to conduct research on the subject before starting on the actual implementation. The research mainly includes finding commonly used algorithms, some of which are described in section \ref{section:theory}, as well as how they are implemented and used in various games and other cases. Further on, the algorithms are then evaluated on their suitability to generate various aspects of realistic city environments. The best candidates are then to be selected for different cases, after which implementation of them can begin. Finer details, such as intersection handling for road and other potential problems, are algorithm-dependent and are to be handled further on in the project. 

The tools to be used throughout the project and how the work is to be organized is described below.

\subsection{Development tools}
Various tools and platforms can be used for the creation of a game development tool. Since the main focus of this project is to develop the PCG algorithms used by the tool, and not the creation of a game engine, the tool will be built using the Unity platform \cite{Unity}. Most of the project members do not possess a lot of game development experience and Unity did not seem to have a steep learning curve, which is why it was chosen for the project.

As a result of the close integration between Unity and the C\# programming language, this is the language which the PCG tool is to be developed in. On top of this, C\# is a type of language that all project members had previous experience working with. To also be able to create 3D assets that are not created directly by the tool, the Blender tool will be used as well \cite{Blender}. However, since the main focus is to develop a PCG tool and not 3D assets, Blender may not be used for the final product.

\subsection{Agile development}
There are many different approaches of developing and managing a software project. Because of uncertainties about the final feature specifications of the developed tool, an iterative approach was deemed necessary, and linear approaches such as the waterfall methodology was to be avoided \cite{Waterfall}. In order to work in an agile way, the objectives of the project have to be organized into relatively short time periods. It is also important to parallelize the development between project members, which is why the project will be developed by following a, perhaps simpler, version of the agile methodology called "Scrum" \cite{Scrum}. Due to its suitability with iterative processes and prior experiences from several project members, this was deemed the most reasonable approach.

In this methodology, the project is divided into "sprints", consisting of an agreed time-span of approximately two weeks. However, due to external factors such as exam weeks and longer periods of self studies, the time-span of some sprints have been adjusted to three weeks instead. How the sprints are preliminary scheduled is displayed in section \ref{fig:timetable}.

Each sprint will start with a planning meeting, consisting of scoping the sprint and dividing tasks among the project members. During sprints, the project members will meet one or a few additional times depending on the length of the sprint, to synchronize the progress. The sprints end with a meeting consisting of a sprint review and a retrospective, to review the outcome of the sprint, as well as to reflect on the sprint in general.